require 'pathname'

module Twine
  module Formatters
    class AppleSwift < Abstract
      SUPPORTS_PLURAL = true
      attr_accessor :stringFileName

      def format_name
        'apple-swift'
      end
      
      def extension
        '.swift'
      end

      def self.can_handle_directory?(path)
        true
      end

      def default_file_name
        return 'R2String+TxtFileName.swift'
      end

      def determine_language_given_path(path)
        raise 'not going to implement'
      end

      def format_file(lang)
        filePath = Pathname.new(@options[:output_path])
        self.stringFileName = filePath.basename.to_s[0..-7]
        impl = "R2String+" + self.stringFileName + ".swift"
        @options[:output_path] = filePath.dirname + impl
        result = super + "\n\n}\n"
      end

      def format_header(lang)
        %(//
// Generated by Twine #{Twine::VERSION}
//

import UIKit

fileprivate let kStringsFileName = "#{stringFileName}"

extension R2String {)
      end

      def format_value(value)
        value.gsub("\"", "\\\"")
      end

      def format_section_header(section)
        "    // MARK: - #{section.name}"
      end

      def key_value_pattern
        %(
    var %{key}: String {
        return NSLocalizedString\("%{key}", tableName: kStringsFileName, bundle: Bundle.main, value: "%{value}", comment: ""\)
    })
      end

      def format_plural_keys(key, plural_hash)
        %(
    func #{key}(count: Int) -> String {
        String.localizedStringWithFormat\(NSLocalizedString\("#{key}", tableName: kStringsFileName, bundle: Bundle.main, value: "/!\\\\ Plurals string value not found", comment: ""\), count\)
    })
      end

      def format_comment(definition, lang)
        comment = ''
        if definition.comment
          comment = "\n    /// #{definition.comment}"
        end
        %(\n    /// Translation in #{lang} :\n    /// #{definition.translations[lang]}#{comment})
      end

    end
  end
end

Twine::Formatters.formatters << Twine::Formatters::AppleSwift.new
